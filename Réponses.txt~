%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Colonel Pierre-Henri      %%
%%   Réponses TD4 prolog       %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%
%%   Exercice 1   %%
%%%%%%%%%%%%%%%%%%%%

  2/
On a des solutions à partir de Proflimite = 18

Les temps d'execution semblent cohérents :

5   ->  0.2 sec
10  ->  0.7 sec
12  ->  4.9 sec
17  ->  2 min 25 sec


  4/
1:  count(N,Lim) :-                                     %% Déclaration du prédicat count
2:    time(( findall( _,                                %% Compte le temps d'execution pour trouver toutes les instances générées
3:      resoudre_avec_profondeur_limite( S, N, Lim ),   %% pour résoudre notre algo avec profondeur limitée
4:      L ),                                            %% avec l : liste des cas possibles
5:    length( L, T ), write_ln(T) )).                   %% trouve la liste et affiche sa taille (nombre de cas possibles)


  5/

?- count(N,5).
Searching...
0
% 153,372 inferences, 0.012 CPU in 0.019 seconds (66% CPU, 12570879 Lips)
true.

?- count(N,10).
Searching...
0
% 6,632,690 inferences, 0.452 CPU in 0.452 seconds (100% CPU, 14681358 Lips)
true.

?- count(N,12).
Searching...
0
% 69,993,714 inferences, 4.615 CPU in 4.619 seconds (100% CPU, 15166914 Lips)
true.

?- count(N,13).
Searching...
0
% 106,292,466 inferences, 7.014 CPU in 7.021 seconds (100% CPU, 15154510 Lips)
true.


  6/ 
L'augmentation du temps d'execution semble exponentielle, ce qui est normal car le nombre "d'inferences" est de plus en plus important. Donc pour 17, il devrait être beaucoup plus long.


%%%%%%%%%%%%%%%%%%%%
%%   Exercice 2   %%
%%%%%%%%%%%%%%%%%%%%


  2/ 
L'algo utilise le principe suivant : on recherche tous les noeuds suivants le noeud actuel et on les ajoute à la pile.
Pour chaque noeud ajouté, on rappelle la fonction de recherche. On va donc chercher à chaque fois les noeuds plus "profonds" au noeud actuel.
Un pile est particulièrement adaptée aux alogorithmes de parcours en profondeur.

  3/
depth_first([[1]],9,P,N).
NewPaths = [[2,1],[3,1]]
NewQueue = [[2,1],[3,1]]
NewPaths = [[4,2,1],[5,2,1]]
NewQueue = [[4,2,1],[5,2,1],[3,1]]
NewPaths = [[8,4,2,1]]
NewQueue = [[8,4,2,1],[5,2,1],[3,1]]
NewPaths = [[9,8,4,2,1]]
NewQueue = [[9,8,4,2,1],[5,2,1],[3,1]]
P = [9, 8, 4, 2, 1],
N = 4 ;
NewPaths = []
NewQueue = [[5,2,1],[3,1]]
NewPaths = []
NewQueue = [[3,1]]
NewPaths = [[6,3,1],[7,3,1]]
NewQueue = [[6,3,1],[7,3,1]]
NewPaths = [[8,6,3,1]]
NewQueue = [[8,6,3,1],[7,3,1]]
NewPaths = [[9,8,6,3,1]]
NewQueue = [[9,8,6,3,1],[7,3,1]]
P = [9, 8, 6, 3, 1],
N = 9 ;
NewPaths = []
NewQueue = [[7,3,1]]
NewPaths = [[9,7,3,1]]
NewQueue = [[9,7,3,1]]
P = [9, 7, 3, 1],
N = 11 ;
NewPaths = []
NewQueue = []
false.

  4/
NewPaths = [[2,1],[3,1]]
NewQueue = [[2,1],[3,1]]
NewPaths = [[4,2,1],[5,2,1]]
NewQueue = [[3,1],[4,2,1],[5,2,1]]
NewPaths = [[6,3,1],[7,3,1]]
NewQueue = [[4,2,1],[5,2,1],[6,3,1],[7,3,1]]
NewPaths = [[8,4,2,1]]
NewQueue = [[5,2,1],[6,3,1],[7,3,1],[8,4,2,1]]
NewPaths = []
NewQueue = [[6,3,1],[7,3,1],[8,4,2,1]]
NewPaths = [[8,6,3,1]]
NewQueue = [[7,3,1],[8,4,2,1],[8,6,3,1]]
NewPaths = [[9,7,3,1]]
NewQueue = [[8,4,2,1],[8,6,3,1],[9,7,3,1]]
NewPaths = [[9,8,4,2,1]]
NewQueue = [[8,6,3,1],[9,7,3,1],[9,8,4,2,1]]
NewPaths = [[9,8,6,3,1]]
NewQueue = [[9,7,3,1],[9,8,4,2,1],[9,8,6,3,1]]
P = [9, 7, 3, 1],
N = 9 ;
NewPaths = []
NewQueue = [[9,8,4,2,1],[9,8,6,3,1]]
P = [9, 8, 4, 2, 1],
N = 10 ;
NewPaths = []
NewQueue = [[9,8,6,3,1]]
P = [9, 8, 6, 3, 1],
N = 11 ;
NewPaths = []
NewQueue = []
false.

  6/
Le nouvel arc ne change pas le résultat (ni en profondeur, ni en largeur). En effet, dans le prédicat extend, "\+ member" exige que le sommet trouvé ne soit pas dans le chemin. Donc lorsque l'algo arrive au sommet 4, il ne propose pas de chemin vers 1.

  7/
Actuellement, l'algo ne prend pas en compte le temps pour passer d'un sommet à un autre. Donc on ne peut toujours pas savoir quel est le chemin le plus court.

  8/
L'algorithme de parcours de graphe en profondeur est beacoup plus efficace en terme d'utilisation de mémoire car il libère la mémoire après chaque chemin trouvé contrairement à l'algo de recherche en largeur.

  9/
	légende :
	P : Chemin
	N : Nombre de noeuds explorés
	C : Coût
solve_b([[1]],9,P,N,C).
P = [9, 7, 3, 1],
N = 9,
C = 150 ;
P = [9, 7, 3, 1],
N = 9,
C = 150 ;
P = [9, 8, 4, 2, 1],
N = 10,
C = 130 ;
P = [9, 8, 4, 2, 1],
N = 10,
C = 130 ;
P = [9, 8, 6, 3, 1],
N = 11,
C = 210 ;
P = [9, 8, 6, 3, 1],
N = 11,
C = 210 ;

solve_d([[1]],9,P,N,C).
P = [9, 8, 4, 2, 1],
N = 4,
C = 130 ;
P = [9, 8, 4, 2, 1],
N = 4,
C = 130 ;
P = [9, 8, 6, 3, 1],
N = 9,
C = 210 ;
P = [9, 8, 6, 3, 1],
N = 9,
C = 210 ;
P = [9, 7, 3, 1],
N = 11,
C = 150 ;
P = [9, 7, 3, 1],
N = 11,
C = 150 ;

Ici on ne peut toujours pas dire quel algo est le plus rapide étant donné qu'ils parcourent toutes les solutions mais ne priorise pas une solution plus faible en coût. Pour ce faire il faudrait un implémenter une fonction qui favorise les déplacements de faible coût.

%%%%%%%%%%%%%%%%%%%%
%%   Exercice 3   %%
%%%%%%%%%%%%%%%%%%%%


	10/
Le coût apparaissant dans arc est la distance entre deux sommets (villes) en utilisant le réseau routier alors que le coût dans straight_line_distance est la distance "à vol d'oiseau".

	11/
?- solve_best(arad,bucharest,P,N,C).
3 3 5 5 5 5 5 6 6 7 6 
P = [bucharest, fagaras, sibiu, arad],
N = 11,
C = 450 ;
8 9 10 10 10 11 12 11 12 12 
P = [bucharest, pitesti, rimnicu, sibiu, arad],
N = 21,
C = 418 ;
14 14 14 14 
P = [bucharest, fagaras, sibiu, oradea, zerind, arad],
N = 25,
C = 607 ;
16 17 18 18 19 19 19 19 18 17 18 18 
P = [bucharest, pitesti, craiova, rimnicu, sibiu, arad],
N = 37,
C = 605 ;
20 21 22 21 22 22 
P = [bucharest, pitesti, rimnicu, sibiu, oradea, zerind, arad],
N = 43,
C = 575 ;
24 24 24 24 24 23 22 22 22 22 22 22 21 20 21 22 23 23 24 24 24 24 23 22 23 23 
P = [bucharest, pitesti, craiova, rimnicu, sibiu, oradea, zerind, arad],
N = 69,
C = 762 ;
25 25 25 24 24 23 23 22 22 22 23 23 23 
P = [bucharest, pitesti, craiova, dobreta, mehadia, lugoj, timisoara, arad],
N = 82,
C = 733 ;
25 25 25 24 23 23 23 23 23 23 22 21 22 22 22 21 20 19 19 19 19 
P = [bucharest, pitesti, rimnicu, craiova, dobreta, mehadia, lugoj, timisoara, arad],
N = 103,
C = 838 ;
21 22 22 21 22 22 22 21 21 20 20 19 19 19 19 18 17 16 
P = [bucharest, fagaras, sibiu, rimnicu, craiova, dobreta, mehadia, lugoj, timisoara|...],
N = 121,
C = 1030 ;
18 18 17 18 18 18 19 19 19 19 19 18 17 16 16 15 14 13 14 14 14 14 13 
P = [bucharest, fagaras, sibiu, rimnicu, pitesti, craiova, dobreta, mehadia, lugoj|...],
N = 144,
C = 1119 ;
14 14 13 12 12 12 11 10 10 10 10 9 9 8 9 8 7 6 5 5 4 3 3 3 2 1 1 0 
false.


?- solve_a(arad,bucharest,P,N,C).
3 3 3 5 5 6 6 6 6 7 7 8 7 8 8 9 9 
P = [bucharest, pitesti, rimnicu, sibiu, arad],
N = 17,
C = 418 ;
11 
P = [bucharest, fagaras, sibiu, arad],
N = 18,
C = 450 ;
13 13 14 14 15 16 16 15 16 17 16 17 17 17 
P = [bucharest, pitesti, rimnicu, sibiu, oradea, zerind, arad],
N = 32,
C = 575 ;
19 19 
P = [bucharest, pitesti, craiova, rimnicu, sibiu, arad],
N = 34,
C = 605 ;
21 
P = [bucharest, fagaras, sibiu, oradea, zerind, arad],
N = 35,
C = 607 ;
23 23 22 22 23 23 24 24 24 24 24 25 25 24 24 23 24 25 26 25 24 25 25 24 25 25 25 25 
P = [bucharest, pitesti, craiova, dobreta, mehadia, lugoj, timisoara, arad],
N = 63,
C = 733 ;
27 27 27 26 26 
P = [bucharest, pitesti, craiova, rimnicu, sibiu, oradea, zerind, arad],
N = 68,
C = 762 ;
28 28 27 27 27 27 27 27 27 27 27 28 27 28 28 27 26 25 25 25 24 
P = [bucharest, pitesti, rimnicu, craiova, dobreta, mehadia, lugoj, timisoara, arad],
N = 89,
C = 838 ;
26 25 26 27 26 25 25 24 23 23 23 23 22 22 22 22 23 23 23 22 21 21 21 21 21 21 21 21 20 19 18 18 18 17 16 15 14 14 
P = [bucharest, fagaras, sibiu, rimnicu, craiova, dobreta, mehadia, lugoj, timisoara|...],
N = 127,
C = 1030 ;
16 15 14 14 15 15 15 15 15 14 14 14 13 13 14 
P = [bucharest, fagaras, sibiu, rimnicu, pitesti, craiova, dobreta, mehadia, lugoj|...],
N = 142,
C = 1119 ;
15 14 13 12 11 11 11 11 10 9 9 10 9 9 9 8 7 7 6 6 5 5 4 4 4 3 2 1 1 0 



	15/
?- solve_best(arad,bucharest,P,N,C).
3 5 5 
P = [bucharest, fagaras, sibiu, arad],
N = 3,
C = 450 ;
7 6 7 8 8 9 8 9 10 
P = [bucharest, pitesti, rimnicu, sibiu, arad],
N = 12,
C = 418 ;
12 11 12 12 13 13 
P = [bucharest, pitesti, craiova, rimnicu, sibiu, arad],
N = 18,
C = 605 ;
15 14 15 15 15 14 13 12 11 11 11 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 9 9 8 8 7 7 7 7 7 8 9 
P = [bucharest, pitesti, craiova, dobreta, mehadia, lugoj, timisoara, arad],
N = 57,
C = 733 ;
11 10 11 11 10 10 11 11 
P = [bucharest, pitesti, rimnicu, craiova, dobreta, mehadia, lugoj, timisoara, arad],
N = 65,
C = 838 ;
13 12 13 13 12 12 12 12 12 13 12 13 13 
P = [bucharest, fagaras, sibiu, rimnicu, craiova, dobreta, mehadia, lugoj, timisoara|...],
N = 78,
C = 1030 ;
15 14 15 14 14 13 13 13 14 14 
P = [bucharest, fagaras, sibiu, rimnicu, pitesti, craiova, dobreta, mehadia, lugoj|...],
N = 88,
C = 1119 ;
15 14 15 15 14 14 14 13 13 12 12 11 11 10 9 8 7 6 6 6 5 5 4 4 3 3 2 2 1 1 2 2 
P = [bucharest, fagaras, sibiu, oradea, zerind, arad],
N = 120,
C = 607 ;
4 3 4 5 5 6 5 6 7 
P = [bucharest, pitesti, rimnicu, sibiu, oradea, zerind, arad],
N = 129,
C = 575 ;
9 8 9 9 10 10 
P = [bucharest, pitesti, craiova, rimnicu, sibiu, oradea, zerind, arad],
N = 135,
C = 762 ;
12 11 12 12 12 11 10 9 8 8 8 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 5 5 4 3 2 1 0 
false.


solve_a(arad,bucharest,P,N,C).
3 5 6 7 7 
P = [bucharest, pitesti, rimnicu, sibiu, arad],
N = 5,
C = 418 ;
9 9 9 
P = [bucharest, fagaras, sibiu, arad],
N = 8,
C = 450 ;
11 11 12 12 12 13 14 15 15 
P = [bucharest, pitesti, rimnicu, sibiu, oradea, zerind, arad],
N = 17,
C = 575 ;
17 18 17 17 
P = [bucharest, pitesti, craiova, rimnicu, sibiu, arad],
N = 21,
C = 605 ;
19 
P = [bucharest, fagaras, sibiu, oradea, zerind, arad],
N = 22,
C = 607 ;
21 21 22 22 21 22 23 23 24 24 25 
P = [bucharest, pitesti, craiova, dobreta, mehadia, lugoj, timisoara, arad],
N = 33,
C = 733 ;
27 26 27 26 26 26 
P = [bucharest, pitesti, craiova, rimnicu, sibiu, oradea, zerind, arad],
N = 39,
C = 762 ;
28 29 29 28 29 28 28 28 29 28 28 29 29 
P = [bucharest, pitesti, rimnicu, craiova, dobreta, mehadia, lugoj, timisoara, arad],
N = 52,
C = 838 ;
31 31 31 30 31 31 31 30 30 30 31 30 30 30 31 30 30 30 30 30 29 29 30 30 29 29 29 29 30 30 29 28 29 28 
P = [bucharest, fagaras, sibiu, rimnicu, craiova, dobreta, mehadia, lugoj, timisoara|...],
N = 86,
C = 1030 ;
30 30 30 30 30 29 28 28 28 27 28 28 27 27 26 26 26 
P = [bucharest, fagaras, sibiu, rimnicu, pitesti, craiova, dobreta, mehadia, lugoj|...],
N = 103,
C = 1119 ;
27 27 27 27 26 26 26 25 25 24 24 23 23 23 23 22 23 22 22 22 21 21 20 19 19 18 17 17 17 16 16 17 16 17 17 17 16 15 14 14 14 14 14 14 13 13 12 12 11 10 10 10 10 9 9 8 7 7 6 5 5 5 4 3 2 2 2 1 0 
false.

A_star en non informé :
solve_a(arad,bucharest,P,N,C).
3 3 3 5 5 6 6 6 6 7 7 8 7 8 8 9 9 
P = [bucharest, pitesti, rimnicu, sibiu, arad],
N = 17,
C = 418 ;

A_star en informé :
solve_a(arad,bucharest,P,N,C).
3 5 6 7 7 
P = [bucharest, pitesti, rimnicu, sibiu, arad],
N = 5,
C = 418 ;

Best_search en non informé :
solve_best(arad,bucharest,P,N,C).
3 3 5 5 5 5 5 6 6 7 6 
P = [bucharest, fagaras, sibiu, arad],
N = 11,
C = 450 ;

Best_search en informé :
solve_best(arad,bucharest,P,N,C).
3 5 5 
P = [bucharest, fagaras, sibiu, arad],
N = 3,
C = 450 ;


Le meilleur chemin est le suivant :
P = [bucharest, pitesti, rimnicu, sibiu, arad],
C = 418 ;

En comparant avec les algos non informés, on remarque que le nombre de noeuds explorés et gardés en mémoire est bien plus important. Un bonne fonction heuristique est donc primordiale pour que ces algos soient efficaces



%%%%%%%%%%%%%%%%%%%%
%%   Exercice 4   %%
%%%%%%%%%%%%%%%%%%%%

  16/
Le fichier blind-search2 contient : 
      un algo de recherche en profondeur avec pile, 
      un algo de recherche en profondeur version prolog
      un algo de recherche en largeur
      un algo de recherche en profondeur limitée
      un algo de recherche en profondeur version itérative
      un algo de recherche en coût uniforme (Dijkstra)

  17/
uni_cost([[arad]],bucharest,P,N).
P = [bucharest, pitesti, rimnicu, sibiu, arad],
N = 17 ;
P = [bucharest, fagaras, sibiu, arad],
N = 18 ;
P = [bucharest, pitesti, rimnicu, sibiu, oradea, zerind, arad],
N = 32 ;
P = [bucharest, pitesti, craiova, rimnicu, sibiu, arad],
N = 34 ;
P = [bucharest, fagaras, sibiu, oradea, zerind, arad],
N = 35 ;
P = [bucharest, pitesti, craiova, dobreta, mehadia, lugoj, timisoara, arad],
N = 63 ;
P = [bucharest, pitesti, craiova, rimnicu, sibiu, oradea, zerind, arad],
N = 68 ;
P = [bucharest, pitesti, rimnicu, craiova, dobreta, mehadia, lugoj, timisoara, arad],
N = 89 ;
P = [bucharest, fagaras, sibiu, rimnicu, craiova, dobreta, mehadia, lugoj, timisoara|...],
N = 127 ;
P = [bucharest, fagaras, sibiu, rimnicu, pitesti, craiova, dobreta, mehadia, lugoj|...],
N = 142 ;
false.

On remarque tout d'abord que cet algo explore beaucoup plus de noeuds que les algos précédents. Cependant il permet de trouver le chemin le plus court en explorant le minimum de noeuds. Même si les algos A* et meilleur d'abord sont plus interessants en terme de ressources, ils ont besoin d'heuristique pour être performants.


  18/
?- iterative_deepening([[arad]],bucharest,P).

depth=1
depth=2
depth=3
depth=4
P = [bucharest, fagaras, sibiu, arad] ;

depth=5
P = [bucharest, fagaras, sibiu, arad] ;
P = [bucharest, pitesti, rimnicu, sibiu, arad] ;

depth=6
P = [bucharest, fagaras, sibiu, arad, zerind, arad] ;
P = [bucharest, fagaras, sibiu, oradea, zerind, arad] ;
P = [bucharest, fagaras, sibiu, arad, sibiu, arad] ;
P = [bucharest, fagaras, sibiu, oradea, sibiu, arad] ;
P = [bucharest, fagaras, sibiu, fagaras, sibiu, arad] ;
P = [bucharest, fagaras, sibiu, arad] ;
P = [bucharest, fagaras, bucharest, fagaras, sibiu, arad] ;
P = [bucharest, pitesti, bucharest, fagaras, sibiu, arad] ;
P = [bucharest, giurgiu, bucharest, fagaras, sibiu, arad] ;
P = [bucharest, urziceni, bucharest, fagaras, sibiu, arad] ;
P = [bucharest, fagaras, sibiu, rimnicu, sibiu, arad] ;
P = [bucharest, pitesti, rimnicu, sibiu, arad] ;
P = [bucharest, pitesti, craiova, rimnicu, sibiu, arad] ;
P = [bucharest, fagaras, sibiu, arad, timisoara, arad] ;

Cet algo itératif permet de trouver tous les chemins possibles mais il ne donne pas le meilleur en terme de coût (mais il donne la profondeur à chaque étape).
De plus on remarque qu'il fonctionne profonfeur par profondeur tout comme l'algo de recherche en largeur. On peut donc en déduire que la complexité est similaire. Par contre l'utilisation de la mémoire est bien meilleur que l'algo de recherche en largeur. Elle semble similaire à celle de l'algo de recherche en profondeur.


%%%%%%%%%%%%%%%%%%%%
%%   Exercice 5   %%
%%%%%%%%%%%%%%%%%%%%


  1/

